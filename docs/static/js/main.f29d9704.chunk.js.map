{"version":3,"sources":["ImageUpload.js","App.js","serviceWorker.js","index.js","keva_electrum.js","keva_ops.js","util.js","client.js","electrum_client.js"],"names":["InputDiv","styled","div","FileIcon","FiImage","UploadIcon","FiUploadCloud","CheckIcon","FiCheckCircle","SpinnerIcon","Spinner","StyledImg","img","ImgContainer","Backdrop","ImageUpload","props","useState","imageURL","setImageURL","onDrop","useCallback","acceptedFiles","forEach","file","reader","FileReader","onabort","console","log","onerror","onload","result","readAsDataURL","onFileChange","useDropzone","getRootProps","getInputProps","icon","pinned","pinning","animation","role","onClick","onUpload","style","alignSelf","fontSize","color","refKey","length","src","marginTop","pointerEvents","Container","Info","p","sleep","milliseconds","Promise","resolve","setTimeout","Main","Component","checkPeers","a","ipfs","swarm","peers","ipfsPeers","cids","pin","ls","cid","type","push","setState","fileToUpload","File","name","add","fileInfo","path","toString","state","feature","ipfsVersion","this","time","Ipfs","create","version","id","ipfsID","timeEnd","error","stop","catch","err","KevaClient","connectMain","ping","getNamespaceInfoFromShortCode","nsInfo","blockchainScripthash_getHistory","getNamespaceScriptHash","namespaceId","history","fetchKeyValueList","keyValues","mergeKeyValueList","JSON","stringify","startIpfs","setInterval","pinnedFiles","map","c","i","key","href","target","marginBottom","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","message","bitcoin","require","reverse","hardcodedPeers","host","ws","mainClient","mainConnected","wasConnectedAtLeastOnce","serverName","getBalanceByAddress","address","Error","script","toOutputScript","hash","crypto","sha256","reversedHash","Buffer","from","blockchainScripthash_getBalance","balance","addr","getConfig","port","status","getTransactionsByAddress","PING_TIMEOUT","promiseTimeout","reject","promisePing","server_ping","race","close","promiseConnect","getTransactionsFullByAddress","txs","ret","tx","blockchainTransaction_get","tx_hash","full","vin","input","txid","prevTxForVin","vout","value","scriptPubKey","addresses","output","inputs","outputs","hex","multiGetBalanceByAddress","batchsize","unconfirmed_balance","chunks","splitIntoChunks","chunk","scripthashes","scripthash2addr","balances","blockchainScripthash_getBalanceBatch","bal","confirmed","unconfirmed","param","multiGetUtxoByAddress","results","blockchainScripthash_listunspentBatch","utxos","utxo","txId","tx_pos","multiGetHistoryByAddress","blockchainScripthash_getHistoryBatch","multiGetTransactionByTxid","txids","verbose","cb","txidsToFetch","Set","totalToFetch","fetched","blockchainTransaction_getBatch","txdata","code","waitTillConnected","waitTillConnectedInterval","retriesCounter","clearInterval","estimateFees","estimateFee","fast","medium","slow","numberOfBlocks","blockchainEstimatefee","serverFeatures","server_features","broadcast","blockchainTransaction_broadcast","broadcastV2","estimateCurrentBlockheight","Math","floor","Date","testConnection","tcpPort","sslPort","client","ElectrumClient","connect","server_version","forceDisconnect","arr","chunkSize","groups","slice","scriptHash","blockchainTransaction_getMerkle","height","merkel","blockchainTransaction_idFromPos","pos","getRandomHardcodedPeer","usingPeer","wss","initElectrum","ver","random","base58check","KEVA_OP_NAMESPACE","KEVA_OP_PUT","KEVA_OP_DELETE","convert","to","str","hexToUtf8","buffer","alloc","j","hexToNamespace","hexStr","decoded","encode","namespaceToHex","nsStr","decode","fixInt","num","intVal","parseInt","numLen","strHex","len","substr","join","reverseHex","kevaToJson","op","displayName","parseKeva","asm","startsWith","parseKevaPut","parseKevaDelete","parseKevaNamespace","emptyBuffer","bscript","nsScript","compile","OPS","OP_2DROP","OP_DROP","OP_RETURN","getNamespaceDataFromTx","ecl","transactions","txidStart","nsStart","stack","pop","ns","find","t","v","nextns","txIds","uniqueTxIds","filter","indexOf","getTxIdFromShortCode","shortCode","prefix","substring","txHash","completeHistory","currentkeyValueList","isFast","txsToFetch","h","txsMap","resultJson","n","foundIndex","findIndex","r","splice","origkeyValues","kv","e","nsRootId","nsData","makeRequest","method","params","jsonrpc","EventEmitter","protocol","options","timeLastCall","electrumConfig","persistencePolicy","maxRetry","callback","getTime","response","secondParam","event","subscribe","removeAllListeners","reconnect","timeout","clearTimeout","onClose","keepAlive","initSocket","client_name","protocol_version","request","features","scripthash","requestBatch","start_height","count","number","raw","rawtx","txPos","merkle","callback_message_queue","_protocol","_options","connectSocket","WebSocket","onopen","onmessage","messageEvent","onMessage","data","onclose","content","createPromiseResult","send","arguments_far_calls","contents","undefined","argz","createPromiseResultBatch","msg","m","body","parse","Array","emit","Object","keys"],"mappings":"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","file":"static/js/main.f29d9704.chunk.js","sourcesContent":["import React, {useCallback, useState} from 'react'\nimport Spinner from 'react-bootstrap/Spinner';\nimport {useDropzone} from 'react-dropzone'\nimport styled from 'styled-components'\nimport { FiImage, FiCheckCircle,  FiUploadCloud} from \"react-icons/fi\";\n\nconst InputDiv = styled.div`\n  align-self: center;\n  borderWidth: 0;\n  margin-top: 20px;\n  margin-bottom: 20px;\n  cursor: pointer;\n  :hover: {\n    color: red;\n  }\n  :focus {\n    outline: none;\n  }\n`\n\nconst FileIcon = styled(FiImage)`\n  color: #2980B9;\n  font-size: 30px;\n  align-self: center;\n  :hover {\n    color: #7FB3D5;\n  }\n`\n\nconst UploadIcon = styled(FiUploadCloud)`\n  cursor: pointer;\n  color: green;\n  font-size: 28px;\n  align-self: center;\n`\n\nconst CheckIcon = styled(FiCheckCircle)`\n  cursor: pointer;\n  color: green;\n  font-size: 28px;\n  align-self: center;\n`\n\nconst SpinnerIcon = styled(Spinner)`\n  color: green;\n  align-self: center;\n`\n\nconst StyledImg = styled.img`\n  height: 300px;\n  width: 300px;\n  object-fit: contain;\n  align-self: center;\n`\n\nconst ImgContainer = styled.div`\n  height: 300px;\n  width: 300px;\n  border-width: 1px;\n  border-style: solid;\n  border-color: #e0e0e0;\n  border-radius: 10px;\n  background-color: #f3f3f3;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: cener;\n`\n\nconst Backdrop = styled.div`\n  align-self: center;\n  position: absolute;\n  top: 330px;\n  left: calc(50% - 20px);\n  height: 40px;\n  width: 40px;\n  border-radius: 40px;\n  background-color: #fff;\n  display: flex;\n  justify-content: center;\n  box-shadow: 3px 3px 3px rgba(50,50,50,0.28);\n`\n\nexport function ImageUpload(props) {\n  const [imageURL, setImageURL] = useState('');\n  const onDrop = useCallback((acceptedFiles) => {\n    acceptedFiles.forEach((file) => {\n      const reader = new FileReader();\n      reader.onabort = () => console.log('file reading was aborted');\n      reader.onerror = () => console.log('file reading has failed');\n      reader.onload = () => {\n        setImageURL(reader.result);\n      }\n      reader.readAsDataURL(file);\n      props.onFileChange(file);\n    })\n\n  }, []);\n\n  const {getRootProps, getInputProps} = useDropzone({onDrop})\n\n  let icon = null;\n  if (props.pinned) {\n    icon = <CheckIcon/>\n  } else if (props.pinning) {\n    icon = (\n      <SpinnerIcon animation=\"border\" role=\"status\">\n      </SpinnerIcon>\n    );\n  } else {\n    icon = <UploadIcon onClick={props.onUpload}/>\n  }\n\n  return (\n    <>\n      <p style={{alignSelf: 'center', fontSize: 18, color: '#555'}}>IPFS Browser Node</p>\n      <InputDiv {...getRootProps({ refKey: 'innerRef' })}>\n        <input {...getInputProps()} />\n        <ImgContainer>\n          {(imageURL.length > 0) ?\n            <StyledImg src={imageURL} />\n            :\n            <>\n              <FileIcon />\n              <p style={{alignSelf: 'center', fontSize: 12, color: '#777', marginTop: 10}}>Click to Add Image</p>\n            </>\n          }\n        </ImgContainer>\n      </InputDiv>\n      {\n        (imageURL.length > 0) &&\n        <Backdrop style={{pointerEvents: props.pinned ? 'none' : 'auto'}}>{ icon }</Backdrop>\n      }\n    </>\n  )\n}\n","import React, { Component } from 'react';\nimport styled from 'styled-components'\nimport Alert from 'react-bootstrap/Alert';\nimport { KevaClient } from './keva_electrum';\nimport {\n  getNamespaceInfoFromShortCode, fetchKeyValueList,\n  getNamespaceScriptHash, mergeKeyValueList\n} from './keva_ops';\nimport Ipfs from 'ipfs';\nimport { ImageUpload } from './ImageUpload';\n\nconst Container = styled.div`\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  margin-top: 20px;\n`;\n\nconst Info = styled.p`\n  align-self: center;\n  text-align: center;\n  font-size: 12px;\n  color: #aaa;\n  line-height: 4px;\n`;\n\nconst sleep = (milliseconds) => {\n  return new Promise(resolve => setTimeout(resolve, milliseconds))\n}\n\nclass Page extends Component {\n\n  constructor(props) {\n    super();\n    this.ipfs = null;\n  }\n\n  render() {\n    const {feature} = this.props;\n    if (!feature) {\n      return <Alert variant=\"danger\">\n        <Alert.Heading>No Connection to ElectrumX server</Alert.Heading>\n        <p>\n          Check your connection again.\n        </p>\n      </Alert>\n    }\n    return (\n      <div>\n        <p>{feature}</p>\n      </div>\n    )\n  }\n}\n\nclass Main extends Component {\n\n  constructor(props) {\n    super();\n    this.state = {\n      feature: '',\n      ipfsVersion: '',\n      ipfsPeers: [],\n      cids: [],\n    };\n  }\n\n  async startIpfs() {\n    if (this.ipfs) {\n      console.log('IPFS already started');\n    } else {\n      try {\n        console.time('IPFS Started');\n        this.ipfs = await Ipfs.create();\n        const ipfsVersion = await this.ipfs.version();\n        const ipfsID = await this.ipfs.id();\n        const ipfsPeers = await this.ipfs.swarm.peers();\n        this.setState({\n          ipfsVersion: ipfsVersion.version,\n          ipfsID: ipfsID.id,\n          ipfsPeers: ipfsPeers,\n        });\n        console.timeEnd('IPFS Started');\n      } catch (error) {\n        console.error('IPFS init error:', error);\n        this.ipfs = null;\n      }\n    }\n  }\n\n  checkPeers = async () => {\n    if (!this.ipfs) {\n      return;\n    }\n    const ipfsPeers = await this.ipfs.swarm.peers();\n    if (ipfsPeers.length > 0) {\n      let cids = [];\n      for await (const { cid, type } of this.ipfs.pin.ls()) {\n        if (type == 'recursive') {\n          cids.push(cid);\n        }\n      }\n      this.setState({cids, ipfsPeers});\n    } else {\n      this.setState({\n        ipfsPeers: [],\n      });\n    }\n  }\n\n  stopIpfs() {\n    if (this.ipfs && this.ipfs.stop) {\n      console.log('Stopping IPFS');\n      this.ipfs.stop().catch(err => console.error(err));\n      this.ipfs = null;\n    }\n  }\n\n  onFileChange = async (file) => {\n    this.fileToUpload = file;\n    this.setState({pinned: false})\n  }\n\n  onUpload = async () => {\n    if (!this.fileToUpload) {\n      return;\n    }\n    this.setState({pinning: true});\n    // This is to remove the \"path\" attribute from this.fileToUpload.\n    let file = new File([this.fileToUpload], this.fileToUpload.name);\n    const fileInfo = await this.ipfs.add(file);\n    console.log('Added file:', fileInfo.path, fileInfo.cid.toString());\n    await sleep(1000);\n    let cids = [];\n    for await (const { cid, type } of this.ipfs.pin.ls()) {\n      if (type == 'recursive') {\n        cids.push(cid);\n      }\n    }\n    this.setState({pinned: true, pinning: false, cids});\n  }\n\n  async getKeva() {\n    // Keva\n    await KevaClient.connectMain();\n    const isConnected = await KevaClient.ping();\n    if (isConnected) {\n      const shortCode = '5570511';\n      let nsInfo = await getNamespaceInfoFromShortCode(KevaClient, shortCode);\n      const history = await KevaClient.blockchainScripthash_getHistory(getNamespaceScriptHash(nsInfo.namespaceId));\n      let keyValues = await fetchKeyValueList(KevaClient, history, [], true);\n      keyValues = mergeKeyValueList(keyValues);\n      this.setState({feature: JSON.stringify(keyValues)});\n    }\n  }\n\n  async componentDidMount() {\n    // Start IPFS.\n    await this.startIpfs();\n    setInterval(async () => await this.checkPeers(), 5000);\n  }\n\n  render() {\n    const {pinned, pinning, cids} = this.state;\n    let pinnedFiles = cids.map((c, i) => {\n      return (\n        <div key={i} style={{alignSelf: 'center'}}>\n          <a href={`https://ipfs.io/ipfs/${c}`} style={{fontSize: 12}} target=\"_blank\">{c.toString()}</a>\n        </div>\n      )\n    })\n    return (\n      <Container>\n        {/*<Page feature={this.state.feature}/> */}\n        <ImageUpload onUpload={this.onUpload} onFileChange={this.onFileChange} pinned={pinned} pinning={pinning}/>\n        <div style={{marginTop: 10, marginBottom: 10, alignSelf: 'center'}}>\n          { pinnedFiles }\n        </div>\n        <Info>Status: {\n          this.state.ipfsPeers.length > 0\n          ?\n          <span style={{color: 'green'}}>{this.state.ipfsPeers.length} Peers Connected</span>\n          :\n          <span style={{color: 'orange'}}>Connecting to Peers ...</span>\n        }\n        </Info>\n        <Info>Peer Id: {this.state.ipfsID}</Info>\n        <Info>IPFS Version: {this.state.ipfsVersion}</Info>\n      </Container>\n    )\n  }\n}\n\nfunction App() {\n  return <Main />;\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import 'bootstrap/dist/css/bootstrap.min.css';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import { ElectrumClient } from './electrum_client';\nconst bitcoin = require('bitcoinjs-lib');\nlet reverse = require('buffer-reverse');\n//let BigNumber = require('bignumber.js');\n\nconst IS_DEV = true;\n\nlet hardcodedPeers = IS_DEV ?\n  [\n    { host: '127.0.0.1', ws: '8080' },\n  ]\n  :\n  [\n    { host: 'ec0.kevacoin.org', ssl: '50002' },\n    { host: 'ec1.kevacoin.org', ssl: '50002' },\n  ];\n\nlet mainClient = false;\nlet mainConnected = false;\nlet wasConnectedAtLeastOnce = false;\nlet serverName = false;\n\nclass KevaElectrumClient {\n\n  async connectMain() {\n    let usingPeer = await this.getRandomHardcodedPeer();\n    try {\n      console.log('begin connection:', JSON.stringify(usingPeer));\n      mainClient = new ElectrumClient(usingPeer.ws, usingPeer.host, usingPeer.wss ? 'wss' : 'ws');\n      const ver = await mainClient.initElectrum({ client: 'keva_web_client', version: '1.4' });\n      if (ver && ver[0]) {\n        console.log('connected to ', ver);\n        serverName = ver[0];\n        mainConnected = true;\n        wasConnectedAtLeastOnce = true;\n      }\n    } catch (e) {\n      mainConnected = false;\n      console.log('bad connection:', JSON.stringify(usingPeer), e);\n    }\n  }\n\n  /**\n   * Returns random hardcoded electrum server guaranteed to work\n   * at the time of writing.\n   *\n   * @returns {Promise<{tcp, host}|*>}\n   */\n  async getRandomHardcodedPeer() {\n    return hardcodedPeers[(hardcodedPeers.length * Math.random()) | 0];\n  }\n\n  /**\n   *\n   * @param address {String}\n   * @returns {Promise<Object>}\n   */\n  getBalanceByAddress = async function(address) {\n    if (!mainClient) throw new Error('Electrum client is not connected');\n    let script = bitcoin.address.toOutputScript(address);\n    let hash = bitcoin.crypto.sha256(script);\n    let reversedHash = Buffer.from(reverse(hash));\n    let balance = await mainClient.blockchainScripthash_getBalance(reversedHash.toString('hex'));\n    balance.addr = address;\n    return balance;\n  };\n\n  getConfig = async function() {\n    if (!mainClient) throw new Error('Electrum client is not connected');\n    return {\n      host: mainClient.host,\n      port: mainClient.port,\n      status: mainClient.status ? 1 : 0,\n      serverName,\n    };\n  };\n\n  /**\n   *\n   * @param address {String}\n   * @returns {Promise<Array>}\n   */\n  getTransactionsByAddress = async function(address) {\n    if (!mainClient) throw new Error('Electrum client is not connected');\n    let script = bitcoin.address.toOutputScript(address);\n    let hash = bitcoin.crypto.sha256(script);\n    let reversedHash = Buffer.from(reverse(hash));\n    let history = await mainClient.blockchainScripthash_getHistory(reversedHash.toString('hex'));\n    return history;\n  };\n\n  PING_TIMEOUT = 5000;\n\n  ping = async function() {\n    try {\n      let promiseTimeout = new Promise((resolve, reject) => {\n        setTimeout(() => reject(new Error('Ping timeout')), this.PING_TIMEOUT);\n      });\n      let promisePing = mainClient.server_ping();\n      await Promise.race([promisePing, promiseTimeout]);\n    } catch (err) {\n      mainConnected = false;\n      mainClient.close();\n      try {\n        let promiseConnect = this.connectMain();\n        let promiseTimeout = new Promise((resolve, reject) => {\n          setTimeout(() => reject(new Error('Ping timeout again')), this.PING_TIMEOUT);\n        });\n        await Promise.race([promiseConnect, promiseTimeout]);\n        if (!mainConnected) {\n          throw new Error(\"Cannot reconnect\");\n        }\n      } catch (connErr) {\n        throw new Error('Bad network');\n      }\n      return true;\n    }\n    return true;\n  };\n\n  getTransactionsFullByAddress = async function(address) {\n    let txs = await this.getTransactionsByAddress(address);\n    let ret = [];\n    for (let tx of txs) {\n      let full = await mainClient.blockchainTransaction_get(tx.tx_hash, true);\n      full.address = address;\n      for (let input of full.vin) {\n        // now we need to fetch previous TX where this VIN became an output, so we can see its amount\n        let prevTxForVin = await mainClient.blockchainTransaction_get(input.txid, true);\n        if (prevTxForVin && prevTxForVin.vout && prevTxForVin.vout[input.vout]) {\n          input.value = prevTxForVin.vout[input.vout].value;\n          // also, we extract destination address from prev output:\n          if (prevTxForVin.vout[input.vout].scriptPubKey && prevTxForVin.vout[input.vout].scriptPubKey.addresses) {\n            input.addresses = prevTxForVin.vout[input.vout].scriptPubKey.addresses;\n          }\n        }\n      }\n\n      for (let output of full.vout) {\n        if (output.scriptPubKey && output.scriptPubKey.addresses) output.addresses = output.scriptPubKey.addresses;\n      }\n      full.inputs = full.vin;\n      full.outputs = full.vout;\n      delete full.vin;\n      delete full.vout;\n      delete full.hex; // compact\n      delete full.hash; // compact\n      ret.push(full);\n    }\n\n    return ret;\n  };\n\n  /**\n   *\n   * @param addresses {Array}\n   * @param batchsize {Number}\n   * @returns {Promise<{balance: number, unconfirmed_balance: number, addresses: object}>}\n   */\n  multiGetBalanceByAddress = async function(addresses, batchsize) {\n    batchsize = batchsize || 100;\n    if (!mainClient) throw new Error('Electrum client is not connected');\n    let ret = { balance: 0, unconfirmed_balance: 0, addresses: {} };\n\n    let chunks = this.splitIntoChunks(addresses, batchsize);\n    for (let chunk of chunks) {\n      let scripthashes = [];\n      let scripthash2addr = {};\n      for (let addr of chunk) {\n        let script = bitcoin.address.toOutputScript(addr);\n        let hash = bitcoin.crypto.sha256(script);\n        let reversedHash = Buffer.from(reverse(hash));\n        reversedHash = reversedHash.toString('hex');\n        scripthashes.push(reversedHash);\n        scripthash2addr[reversedHash] = addr;\n      }\n\n      let balances = [];\n      balances = await mainClient.blockchainScripthash_getBalanceBatch(scripthashes);\n\n      for (let bal of balances) {\n        ret.balance += +bal.result.confirmed;\n        ret.unconfirmed_balance += +bal.result.unconfirmed;\n        ret.addresses[scripthash2addr[bal.param]] = bal.result;\n      }\n    }\n\n    return ret;\n  };\n\n  multiGetUtxoByAddress = async function(addresses, batchsize) {\n    batchsize = batchsize || 100;\n    if (!mainClient) throw new Error('Electrum client is not connected');\n    let ret = {};\n\n    let chunks = this.splitIntoChunks(addresses, batchsize);\n    for (let chunk of chunks) {\n      let scripthashes = [];\n      let scripthash2addr = {};\n      for (let addr of chunk) {\n        let script = bitcoin.address.toOutputScript(addr);\n        let hash = bitcoin.crypto.sha256(script);\n        let reversedHash = Buffer.from(reverse(hash));\n        reversedHash = reversedHash.toString('hex');\n        scripthashes.push(reversedHash);\n        scripthash2addr[reversedHash] = addr;\n      }\n\n      let results = [];\n      results = await mainClient.blockchainScripthash_listunspentBatch(scripthashes);\n\n      for (let utxos of results) {\n        ret[scripthash2addr[utxos.param]] = utxos.result;\n        for (let utxo of ret[scripthash2addr[utxos.param]]) {\n          utxo.address = scripthash2addr[utxos.param];\n          utxo.txId = utxo.tx_hash;\n          utxo.vout = utxo.tx_pos;\n          delete utxo.tx_pos;\n          delete utxo.tx_hash;\n        }\n      }\n    }\n\n    return ret;\n  };\n\n  multiGetHistoryByAddress = async function(addresses, batchsize) {\n    batchsize = batchsize || 100;\n    if (!mainClient) throw new Error('Electrum client is not connected');\n    let ret = {};\n\n    let chunks = this.splitIntoChunks(addresses, batchsize);\n    for (let chunk of chunks) {\n      let scripthashes = [];\n      let scripthash2addr = {};\n      for (let addr of chunk) {\n        let script = bitcoin.address.toOutputScript(addr);\n        let hash = bitcoin.crypto.sha256(script);\n        let reversedHash = Buffer.from(reverse(hash));\n        reversedHash = reversedHash.toString('hex');\n        scripthashes.push(reversedHash);\n        scripthash2addr[reversedHash] = addr;\n      }\n\n      let results = [];\n      results = await mainClient.blockchainScripthash_getHistoryBatch(scripthashes);\n\n      for (let history of results) {\n        ret[scripthash2addr[history.param]] = history.result;\n        for (let hist of ret[scripthash2addr[history.param]]) {\n          hist.address = scripthash2addr[history.param];\n        }\n      }\n    }\n\n    return ret;\n  };\n\n  multiGetTransactionByTxid = async function(txids, batchsize, verbose, cb) {\n    batchsize = batchsize || 45;\n    // this value is fine-tuned so althrough wallets in test suite will occasionally\n    // throw 'response too large (over 1,000,000 bytes', test suite will pass\n    verbose = verbose !== false;\n    if (!mainClient) throw new Error('Electrum client is not connected');\n    let ret = {};\n    let txidsToFetch = [...new Set(txids)]; // deduplicate just for any case\n    let totalToFetch = txidsToFetch.length;\n    let fetched = 0;\n    let chunks = this.splitIntoChunks(txidsToFetch, batchsize);\n    for (let chunk of chunks) {\n      let results = [];\n      results = await mainClient.blockchainTransaction_getBatch(chunk, verbose);\n      if (cb) {\n        fetched += chunk.length;\n        cb(totalToFetch, fetched);\n      }\n\n      for (let txdata of results) {\n        if (txdata.error && txdata.error.code === -32600) {\n          // response too large\n          // lets do single call, that should go through okay:\n          txdata.result = await mainClient.blockchainTransaction_get(txdata.param, verbose);\n        }\n        ret[txdata.param] = txdata.result;\n      }\n    }\n\n    return ret;\n  };\n\n  /**\n   * Simple waiter till `mainConnected` becomes true (which means\n   * it Electrum was connected in other function), or timeout 30 sec.\n   *\n   *\n   * @returns {Promise<Promise<*> | Promise<*>>}\n   */\n  waitTillConnected = async function() {\n    let waitTillConnectedInterval = false;\n    let retriesCounter = 0;\n    return new Promise(function(resolve, reject) {\n      waitTillConnectedInterval = setInterval(() => {\n        if (mainConnected) {\n          clearInterval(waitTillConnectedInterval);\n          resolve(true);\n        }\n\n        if (wasConnectedAtLeastOnce && mainClient.status === 1) {\n          clearInterval(waitTillConnectedInterval);\n          mainConnected = true;\n          resolve(true);\n        }\n\n        if (retriesCounter++ >= 30) {\n          clearInterval(waitTillConnectedInterval);\n          reject(new Error('Waiting for Electrum connection timeout'));\n        }\n      }, 500);\n    });\n  };\n\n  estimateFees = async function() {\n    const fast = await this.estimateFee(1);\n    const medium = await this.estimateFee(18);\n    const slow = await this.estimateFee(144);\n    return { fast, medium, slow };\n  };\n\n  /**\n   * Returns the estimated transaction fee to be confirmed within a certain number of blocks\n   *\n   * @param numberOfBlocks {number} The number of blocks to target for confirmation\n   * @returns {Promise<number>} Satoshis per byte\n   */\n  estimateFee = async function(numberOfBlocks) {\n    if (!mainClient) throw new Error('Electrum client is not connected');\n    numberOfBlocks = numberOfBlocks || 1;\n    let coinUnitsPerKilobyte = await mainClient.blockchainEstimatefee(numberOfBlocks);\n    if (coinUnitsPerKilobyte === -1) return 1;\n    /*\n    return Math.round(\n      new BigNumber(coinUnitsPerKilobyte)\n        .dividedBy(1024)\n        .multipliedBy(100000000)\n        .toNumber(),\n    );\n    */\n    return 1024;\n  };\n\n  serverFeatures = async function() {\n    if (!mainClient) throw new Error('Electrum client is not connected');\n    return mainClient.server_features();\n  };\n\n  broadcast = async function(hex) {\n    if (!mainClient) throw new Error('Electrum client is not connected');\n    try {\n      const broadcast = await mainClient.blockchainTransaction_broadcast(hex);\n      return broadcast;\n    } catch (error) {\n      return error;\n    }\n  };\n\n  broadcastV2 = async function(hex) {\n    if (!mainClient) throw new Error('Electrum client is not connected');\n    return mainClient.blockchainTransaction_broadcast(hex);\n  };\n\n  estimateCurrentBlockheight = function() {\n    const baseTs = 1587570465609; // uS\n    const baseHeight = 627179;\n    return Math.floor(baseHeight + (+new Date() - baseTs) / 1000 / 60 / 9.5);\n  };\n\n\n  /**\n   *\n   * @param host\n   * @param tcpPort\n   * @param sslPort\n   * @returns {Promise<boolean>} Whether provided host:port is a valid electrum server\n   */\n  testConnection = async function(host, tcpPort, sslPort) {\n    let client = new ElectrumClient(sslPort || tcpPort, host, sslPort ? 'tls' : 'tcp');\n    try {\n      await client.connect();\n      await client.server_version('2.7.11', '1.4');\n      await client.server_ping();\n      client.close();\n      return true;\n    } catch (_) {\n      return false;\n    }\n  };\n\n  forceDisconnect = () => {\n    mainClient.close();\n  };\n\n  splitIntoChunks = function(arr, chunkSize) {\n    let groups = [];\n    let i;\n    for (i = 0; i < arr.length; i += chunkSize) {\n      groups.push(arr.slice(i, i + chunkSize));\n    }\n    return groups;\n  };\n\n  blockchainTransaction_get = async function(tx_hash, verbose) {\n    const tx = await mainClient.blockchainTransaction_get(tx_hash, verbose);\n    return tx;\n  }\n\n  blockchainTransaction_getBatch = async function(tx_hash, verbose) {\n    return await mainClient.blockchainTransaction_getBatch(tx_hash, verbose);\n  }\n\n  blockchainScripthash_getHistory = async function(scriptHash) {\n    return await mainClient.blockchainScripthash_getHistory(scriptHash);\n  }\n\n  blockchainTransaction_getMerkle = async function(txid, height, merkel) {\n    return await mainClient.blockchainTransaction_getMerkle(txid, height, merkel);\n  }\n\n  blockchainTransaction_idFromPos = async function(height, pos) {\n    let txid = await mainClient.blockchainTransaction_idFromPos(height, pos);\n    return txid;\n  }\n\n}\n\nexport const KevaClient = new KevaElectrumClient();\n","/* eslint eqeqeq: \"off\" */\nconst bitcoin = require('bitcoinjs-lib');\nconst base58check = require('bs58check')\nconst coinSelectAccumulative = require('coinselect/accumulative');\n\nexport const KEVA_OP_NAMESPACE = 0xd0;\nexport const KEVA_OP_PUT = 0xd1;\nexport const KEVA_OP_DELETE = 0xd2;\n\nconst delete_key_err = '';\nconst update_key_err = '';\n\nconst convert = (from, to) => str => Buffer.from(str, from).toString(to)\nconst utf8ToHex = convert('utf8', 'hex')\nconst hexToUtf8 = convert('hex', 'utf8')\n\nconst DUMMY_TXID = 'c70483b4613b18e750d0b1087ada28d713ad1e406ebc87d36f94063512c5f0dd';\n\nexport function waitPromise(milliseconds) {\n  return new Promise(resolve => setTimeout(resolve, milliseconds));\n}\n\nexport function reverse(src) {\n  let buffer = Buffer.alloc(src.length)\n\n  for (let i = 0, j = src.length - 1; i <= j; ++i, --j) {\n    buffer[i] = src[j]\n    buffer[j] = src[i]\n  }\n\n  return buffer\n}\n\nexport function isKevaNamespace(code) {\n  return code === KEVA_OP_NAMESPACE;\n}\n\nexport function isKevaPut(code) {\n  return code === KEVA_OP_PUT;\n}\n\nexport function isKevaDelete(code) {\n  return code === KEVA_OP_DELETE;\n}\n\nexport function hexToNamespace(hexStr) {\n  let decoded = Buffer.from(hexStr, \"hex\")\n  return base58check.encode(decoded);\n}\n\nexport function namespaceToHex(nsStr) {\n  return base58check.decode(nsStr);\n}\n\nfunction reverseHex(strHex) {\n  if ((strHex.length % 2) != 0) {\n    strHex = '0' + strHex;\n  }\n  const result = [];\n  let len = strHex.length - 2;\n  while (len >= 0) {\n    result.push(strHex.substr(len, 2));\n    len -= 2;\n  }\n  return result.join('');\n}\n\nfunction fixInt(num) {\n  let intVal = parseInt(num, 10);\n  if (intVal.toString(10) != num) {\n    return num;\n  }\n  if (intVal > 2147483647) {\n    return num;\n  }\n  if (intVal < 0) {\n    // See set_vch method in script.h in bitcoin code.\n    let scriptNum = (-intVal).toString(16);\n    const numLen = scriptNum.length;\n    if (numLen == 2) {\n      intVal = -intVal + 0x80;\n    } else if (numLen <= 4) {\n      intVal = -intVal + 0x8000;\n    } else if (numLen <= 6) {\n      intVal = -intVal + 0x800000;\n    } else if (numLen <= 8) {\n      intVal = -intVal + 0x80000000;\n    }\n  }\n  return reverseHex(intVal.toString(16));\n}\n\nfunction kevaToJson(result) {\n  if (result[0] === KEVA_OP_NAMESPACE) {\n      return {\n          op: 'KEVA_OP_NAMESPACE',\n          namespaceId: hexToNamespace(result[1]),\n          displayName: hexToUtf8(fixInt(result[2]))\n      }\n  } else if (result[0] === KEVA_OP_PUT) {\n      return {\n          op: 'KEVA_OP_PUT',\n          namespaceId: hexToNamespace(result[1]),\n          key: hexToUtf8(fixInt(result[2])),\n          value: hexToUtf8(fixInt(result[3]))\n      }\n  } else if (result[0] === KEVA_OP_DELETE) {\n      return {\n          op: 'KEVA_OP_DELETE',\n          namespaceId: hexToNamespace(result[1]),\n          key: hexToUtf8(fixInt(result[2]))\n      }\n  } else {\n      return null;\n  }\n}\n\nexport function parseKevaPut(asm) {\n  let re = /^OP_KEVA_PUT\\s([0-9A-Fa-f]+)\\s(-?[0-9A-Fa-f]+)\\s(-?[0-9A-Fa-f]+)/;\n  let match = asm.match(re);\n  if (!match || match.length !== 4) {\n    return null;\n  }\n  return [KEVA_OP_PUT, ...match.slice(1)];\n}\n\nexport function parseKevaDelete(asm) {\n  let re = /^OP_KEVA_DELETE\\s([0-9A-Fa-f]+)\\s(-?[0-9A-Fa-f]+)/;\n  let match = asm.match(re);\n  if (!match || match.length !== 3) {\n    return null;\n  }\n  return [KEVA_OP_DELETE, ...match.slice(1)];\n}\n\nexport function parseKevaNamespace(asm) {\n  let re = /^OP_KEVA_NAMESPACE\\s([0-9A-Fa-f]+)\\s(-?[0-9A-Fa-f]+)/;\n  let match = asm.match(re);\n  if (!match || match.length !== 3) {\n    return null;\n  }\n  return [KEVA_OP_NAMESPACE, ...match.slice(1)];\n}\n\nexport function parseKeva(asm) {\n  if (asm.startsWith(\"OP_KEVA_PUT\")) {\n    return parseKevaPut(asm);\n  } else if (asm.startsWith(\"OP_KEVA_DELETE\")) {\n    return parseKevaDelete(asm);\n  } else if (asm.startsWith(\"OP_KEVA_NAMESPACE\")) {\n    return parseKevaNamespace(asm);\n  }\n  return null;\n}\n\nexport function toScriptHash(addr) {\n  let script = bitcoin.address.toOutputScript(addr);\n  let hash = bitcoin.crypto.sha256(script);\n  let reversedHash = Buffer.from(reverse(hash));\n  return reversedHash.toString('hex');\n}\n\nexport function getNamespaceScriptHash(namespaceId) {\n  let emptyBuffer = Buffer.alloc(0);\n  let bscript = bitcoin.script;\n  let nsScript = bscript.compile([\n    KEVA_OP_PUT,\n    namespaceToHex(namespaceId),\n    emptyBuffer,\n    bscript.OPS.OP_2DROP,\n    bscript.OPS.OP_DROP,\n    bscript.OPS.OP_RETURN]);\n  let hash = bitcoin.crypto.sha256(nsScript);\n  let reversedHash = Buffer.from(reverse(hash));\n  return reversedHash.toString('hex');\n}\n\nexport async function getNamespaceDataFromTx(ecl, transactions, txidStart, nsStart) {\n  let stack = [];\n  stack.push([txidStart, nsStart]);\n  while (stack.length > 0) {\n    let [txid, ns] = stack.pop();\n    let tx = transactions.find(t => t.txid == txid);\n    if (!tx) {\n      // Not found in the cache, try to fetch it from the server.\n      tx = await ecl.blockchainTransaction_get(txid, true);\n    }\n\n    // From transactions, tx.outputs\n    // From server: tx.vout\n    const vout = tx.outputs || tx.vout;\n    for (let v of vout) {\n      let result = parseKeva(v.scriptPubKey.asm);\n      if (!result) {\n        continue;\n      }\n\n      if (result[0] === KEVA_OP_NAMESPACE) {\n        if (!ns || ns === result[1]) {\n          return {\n            txid,\n            result,\n            address: v.scriptPubKey.addresses[0],\n          };\n        }\n      }\n\n      let nextns = result[1];\n      if (!ns || nextns === ns) {\n        // From transactions, tx.inputs\n        // From server: tx.vin\n        const vin = tx.inputs || tx.vin;\n        let txIds = vin.map(t => t.txid);\n        let uniqueTxIds = txIds.filter((v, i, a) => a.indexOf(v) === i);\n        for (let t of uniqueTxIds) {\n          stack.push([t, nextns]);\n        }\n      }\n    }\n  }\n  return null;\n}\n\nfunction getNamespaceCreationScript(nsName, address, txId, n) {\n  let bcrypto = bitcoin.crypto;\n  let nBuf = Buffer.from(n.toString(), 'utf-8');\n  let txBuf = reverse(Buffer.from(txId, 'hex'));\n  let namespaceId = bcrypto.hash160(Buffer.concat([txBuf, nBuf]));\n  var prefixNS = Buffer.from([53])\n  namespaceId = Buffer.concat([prefixNS, namespaceId]);\n  let displayName = Buffer.from(utf8ToHex(nsName), 'hex');\n\n  let bscript = bitcoin.script;\n  let baddress = bitcoin.address;\n  let nsScript = bscript.compile([\n    KEVA_OP_NAMESPACE,\n    namespaceId,\n    displayName,\n    bscript.OPS.OP_2DROP,\n    bscript.OPS.OP_HASH160,\n    baddress.fromBase58Check(address).hash,\n    bscript.OPS.OP_EQUAL]);\n  return {nsScript, namespaceId};\n}\n\nexport async function createKevaNamespace(wallet, requestedSatPerByte, nsName) {\n  await wallet.fetchBalance();\n  await wallet.fetchTransactions();\n  await wallet.fetchUtxo();\n  const utxos = wallet.getUtxo();\n  const namespaceAddress = await wallet.getAddressAsync();\n  let { nsScript } = getNamespaceCreationScript(nsName, namespaceAddress, DUMMY_TXID, 0);\n\n  // Namespace needs at least 0.01 KVA.\n  const namespaceValue = 1000000;\n  let targets = [{\n    address: namespaceAddress, value: namespaceValue,\n    script: nsScript\n  }];\n\n  const transactions = wallet.getTransactions();\n  let nonNamespaceUtxos = await getNonNamespaceUxtos(wallet, transactions, utxos);\n  let { inputs, outputs, fee } = coinSelectAccumulative(nonNamespaceUtxos, targets, requestedSatPerByte);\n\n  // inputs and outputs will be undefined if no solution was found\n  if (!inputs || !outputs) {\n    throw new Error('Not enough balance. Try sending smaller amount');\n  }\n\n  const psbt = new bitcoin.Psbt();\n  psbt.setVersion(0x7100); // Kevacoin transaction.\n  let keypairs = [];\n  for (let i = 0; i < inputs.length; i++) {\n    let input = inputs[i];\n    const pubkey = wallet._getPubkeyByAddress(input.address);\n    if (!pubkey) {\n      throw new Error('Failed to get pubKey');\n    }\n    const p2wpkh = bitcoin.payments.p2wpkh({ pubkey });\n    const p2sh = bitcoin.payments.p2sh({ redeem: p2wpkh });\n\n    psbt.addInput({\n      hash: input.txId,\n      index: input.vout,\n      witnessUtxo: {\n        script: p2sh.output,\n        value: input.value,\n      },\n      redeemScript: p2wpkh.output,\n    });\n\n    let keyPair = bitcoin.ECPair.fromWIF(input.wif);\n    keypairs.push(keyPair);\n  }\n\n  let returnNamespaceId;\n  for (let i = 0; i < outputs.length; i++) {\n    let output = outputs[i];\n    if (!output.address) {\n      // Change address.\n      output.address = await wallet.getChangeAddressAsync();\n    }\n\n    if (i == 0) {\n      // The namespace creation script.\n      if (output.value != 1000000) {\n        throw new Error('Namespace creation script has incorrect value.');\n      }\n      const { nsScript, namespaceId } = getNamespaceCreationScript(nsName, namespaceAddress, inputs[0].txId, inputs[0].vout);\n      returnNamespaceId = namespaceId;\n      psbt.addOutput({\n        script: nsScript,\n        value: output.value,\n      });\n    } else {\n      psbt.addOutput({\n        address: output.address,\n        value: output.value,\n      });\n    }\n  }\n\n  for (let i = 0; i < keypairs.length; i++) {\n    psbt.signInput(i, keypairs[i]);\n    if (!psbt.validateSignaturesOfInput(i)) {\n      throw new Error('Invalid signature for input #' + i);\n    }\n  }\n\n  psbt.finalizeAllInputs();\n  let hexTx = psbt.extractTransaction(true).toHex();\n  return {tx: hexTx, namespaceId: hexToNamespace(returnNamespaceId), fee};\n}\n\nfunction getKeyValueUpdateScript(namespaceId, address, key, value) {\n  const keyBuf = Buffer.from(utf8ToHex(key), 'hex');\n  const valueBuf = Buffer.from(utf8ToHex(value), 'hex');\n\n  let bscript = bitcoin.script;\n  let baddress = bitcoin.address;\n  let nsScript = bscript.compile([\n    KEVA_OP_PUT,\n    namespaceToHex(namespaceId),\n    keyBuf,\n    valueBuf,\n    bscript.OPS.OP_2DROP,\n    bscript.OPS.OP_DROP,\n    bscript.OPS.OP_HASH160,\n    baddress.fromBase58Check(address).hash,\n    bscript.OPS.OP_EQUAL]);\n\n  return nsScript;\n}\n\nfunction getKeyValueDeleteScript(namespaceId, address, key) {\n  const keyBuf = Buffer.from(utf8ToHex(key), 'hex');\n\n  let bscript = bitcoin.script;\n  let baddress = bitcoin.address;\n  let nsScript = bscript.compile([\n    KEVA_OP_DELETE,\n    namespaceToHex(namespaceId),\n    keyBuf,\n    bscript.OPS.OP_2DROP,\n    bscript.OPS.OP_HASH160,\n    baddress.fromBase58Check(address).hash,\n    bscript.OPS.OP_EQUAL]);\n\n  return nsScript;\n}\n\nexport function getNonNamespaceUxtosSync(transactions, utxos) {\n  let nonNSutxos = [];\n  for (let u of utxos) {\n    const tx = transactions.find(t => t.txid == u.txId);\n    if (!tx) {\n      continue;\n    }\n    const v = tx.outputs[u.vout];\n    let result = parseKeva(v.scriptPubKey.asm);\n    let isNSTx = !!result;\n    if (!isNSTx) {\n      nonNSutxos.push(u);\n    }\n  }\n  return nonNSutxos;\n}\n\nexport async function getNonNamespaceUxtos(wallet, transactions, utxos, tryAgain) {\n  let nonNSutxos = [];\n  for (let u of utxos) {\n    const tx = transactions.find(t => t.txid == u.txId);\n    if (!tx) {\n      continue;\n    }\n    const v = tx.outputs[u.vout];\n    let result = parseKeva(v.scriptPubKey.asm);\n    let isNSTx = !!result;\n    if (!isNSTx) {\n      nonNSutxos.push(u);\n    }\n  }\n\n  if (nonNSutxos.length == 0 && !tryAgain) {\n    // Try again.\n    console.log('Try again for getNonNamespaceUxtos')\n    await waitPromise(2000);\n    await wallet.fetchBalance();\n    await wallet.fetchTransactions();\n    await wallet.fetchUtxo();\n    const transactions = wallet.getTransactions();\n    let utxos = wallet.getUtxo();\n    return await getNonNamespaceUxtos(wallet, transactions, utxos, true);\n  }\n  return nonNSutxos;\n}\n\nexport async function scanForNamespaces(wallet) {\n  let results = [];\n  const txs = wallet.getTransactions();\n  for (let tx of txs) {\n    for (let vout of tx.outputs) {\n      const keva = parseKeva(vout.scriptPubKey.asm);\n      if (keva) {\n        results.push({\n          tx: tx.txid,\n          n: vout.n,\n          address: vout.scriptPubKey.addresses[0],\n          keva: kevaToJson(keva),\n        });\n      }\n    }\n  }\n  return results;\n}\n\nconst TRY_UTXO_COUNT = 2;\nexport async function getNamespaceUtxo(wallet, namespaceId) {\n  for (let i = 0; i < TRY_UTXO_COUNT; i++) {\n    await wallet.fetchUtxo();\n    const utxos = wallet.getUtxo();\n    const results = await scanForNamespaces(wallet);\n    for (let r of results) {\n      if (r.keva.namespaceId === namespaceId) {\n        for (let t of utxos) {\n          if (r.tx == t.txId && r.n == t.vout) {\n            return t;\n          }\n        }\n      }\n    }\n    // No namespace UXTO, try again.\n    await waitPromise(2000);\n    await wallet.fetchBalance();\n    await wallet.fetchTransactions();\n  }\n  return null;\n}\n\nexport async function updateKeyValue(wallet, requestedSatPerByte, namespaceId, key, value) {\n  await wallet.fetchBalance();\n  await wallet.fetchTransactions();\n  let nsUtxo = await getNamespaceUtxo(wallet, namespaceId);\n  if (!nsUtxo) {\n    throw new Error(update_key_err);\n  }\n\n  const namespaceAddress = await wallet.getAddressAsync();\n  const nsScript = getKeyValueUpdateScript(namespaceId, namespaceAddress, key, value);\n\n  // Namespace needs at least 0.01 KVA.\n  const namespaceValue = 1000000;\n  let targets = [{\n    address: namespaceAddress, value: namespaceValue,\n    script: nsScript\n  }];\n\n  const transactions = wallet.getTransactions();\n  let utxos = wallet.getUtxo();\n  let nonNamespaceUtxos = await getNonNamespaceUxtos(wallet, transactions, utxos);\n  // Move the nsUtxo to the first one, so that it will always be used.\n  nonNamespaceUtxos.unshift(nsUtxo);\n  let { inputs, outputs, fee } = coinSelectAccumulative(nonNamespaceUtxos, targets, requestedSatPerByte);\n\n  // inputs and outputs will be undefined if no solution was found\n  if (!inputs || !outputs) {\n    throw new Error('Not enough balance. Try sending smaller amount');\n  }\n\n  const psbt = new bitcoin.Psbt();\n  psbt.setVersion(0x7100); // Kevacoin transaction.\n  let keypairs = [];\n  for (let i = 0; i < inputs.length; i++) {\n    let input = inputs[i];\n    const pubkey = wallet._getPubkeyByAddress(input.address);\n    if (!pubkey) {\n      throw new Error('Failed to get pubKey');\n    }\n    const p2wpkh = bitcoin.payments.p2wpkh({ pubkey });\n    const p2sh = bitcoin.payments.p2sh({ redeem: p2wpkh });\n\n    psbt.addInput({\n      hash: input.txId,\n      index: input.vout,\n      witnessUtxo: {\n        script: p2sh.output,\n        value: input.value,\n      },\n      redeemScript: p2wpkh.output,\n    });\n\n    let keyPair = bitcoin.ECPair.fromWIF(input.wif);\n    keypairs.push(keyPair);\n  }\n\n  for (let i = 0; i < outputs.length; i++) {\n    let output = outputs[i];\n    if (!output.address) {\n      // Change address.\n      output.address = await wallet.getChangeAddressAsync();\n    }\n\n    if (i == 0) {\n      // The namespace creation script.\n      if (output.value != 1000000) {\n        throw new Error('Key update script has incorrect value.');\n      }\n      const nsScript = getKeyValueUpdateScript(namespaceId, namespaceAddress, key, value);\n      psbt.addOutput({\n        script: nsScript,\n        value: output.value,\n      });\n    } else {\n      psbt.addOutput({\n        address: output.address,\n        value: output.value,\n      });\n    }\n  }\n\n  for (let i = 0; i < keypairs.length; i++) {\n    psbt.signInput(i, keypairs[i]);\n    if (!psbt.validateSignaturesOfInput(i)) {\n      throw new Error('Invalid signature for input #' + i);\n    }\n  }\n\n  psbt.finalizeAllInputs();\n  let hexTx = psbt.extractTransaction(true).toHex();\n  return {tx: hexTx, fee};\n}\n\nconst REPLY_COST = 1000000;\n\nfunction createReplyKey(txId, shortCode) {\n  return `:${txId.substring(0, 8)}:${shortCode}`\n}\n\nexport function parseReplyKey(key) {\n  const regexReply = /^:([0-9a-f]+):([0-9]+)$/gm;\n  let matches = regexReply.exec(key);\n  if (!matches) {\n    return false;\n  }\n  return {partialTxId: matches[1], shortCode: matches[2]};\n}\n\nfunction createRewardKey(txId, shortCode) {\n  return `$${txId.substring(0, 8)}:${shortCode}`\n}\n\nexport function parseRewardKey(key) {\n  const regexReply = /^\\$([0-9a-f]+):([0-9]+)$/gm;\n  let matches = regexReply.exec(key);\n  if (!matches) {\n    return false;\n  }\n  return {partialTxId: matches[1], shortCode: matches[2]};\n}\n\nconst MIN_REWARD = 10000000;\n\n// Send a reward to a post(key/value pair).\n// rewardRootAddress: the root namespace of the post.\n// replyTxid: the txid of the post\n//\nexport async function rewardKeyValue(wallet, requestedSatPerByte, namespaceId, shortCode, value, amount, rewardRootAddress, replyTxid) {\n  await wallet.fetchBalance();\n  await wallet.fetchTransactions();\n  let nsUtxo = await getNamespaceUtxo(wallet, namespaceId);\n  if (!nsUtxo) {\n    throw new Error(update_key_err);\n  }\n\n  if (amount < MIN_REWARD) {\n    throw new Error('Amount must be at least 0.1 KVA');\n  }\n\n  // To reward to a post, the key must be :replyTxid.\n  const key = createRewardKey(replyTxid, shortCode);\n  const namespaceAddress = await wallet.getAddressAsync();\n  const nsScript = getKeyValueUpdateScript(namespaceId, namespaceAddress, key, value);\n\n  // Namespace needs at least 0.01 KVA.\n  const namespaceValue = 1000000;\n  let targets = [{\n    address: namespaceAddress, value: namespaceValue,\n    script: nsScript\n  }, {\n    address: rewardRootAddress, value: amount,\n  }];\n\n  const transactions = wallet.getTransactions();\n  let utxos = wallet.getUtxo();\n  let nonNamespaceUtxos = await getNonNamespaceUxtos(wallet, transactions, utxos);\n  // Move the nsUtxo to the first one, so that it will always be used.\n  nonNamespaceUtxos.unshift(nsUtxo);\n  let { inputs, outputs, fee } = coinSelectAccumulative(nonNamespaceUtxos, targets, requestedSatPerByte);\n\n  // inputs and outputs will be undefined if no solution was found\n  if (!inputs || !outputs) {\n    throw new Error('Not enough balance. Try sending smaller amount');\n  }\n\n  const psbt = new bitcoin.Psbt();\n  psbt.setVersion(0x7100); // Kevacoin transaction.\n  let keypairs = [];\n  for (let i = 0; i < inputs.length; i++) {\n    let input = inputs[i];\n    const pubkey = wallet._getPubkeyByAddress(input.address);\n    if (!pubkey) {\n      throw new Error('Failed to get pubKey');\n    }\n    const p2wpkh = bitcoin.payments.p2wpkh({ pubkey });\n    const p2sh = bitcoin.payments.p2sh({ redeem: p2wpkh });\n\n    psbt.addInput({\n      hash: input.txId,\n      index: input.vout,\n      witnessUtxo: {\n        script: p2sh.output,\n        value: input.value,\n      },\n      redeemScript: p2wpkh.output,\n    });\n\n    let keyPair = bitcoin.ECPair.fromWIF(input.wif);\n    keypairs.push(keyPair);\n  }\n\n  for (let i = 0; i < outputs.length; i++) {\n    let output = outputs[i];\n    if (!output.address) {\n      // Change address.\n      output.address = await wallet.getChangeAddressAsync();\n    }\n\n    if (i == 0) {\n      // The namespace creation script.\n      if (output.value != 1000000) {\n        throw new Error('Key update script has incorrect value.');\n      }\n      const nsScript = getKeyValueUpdateScript(namespaceId, namespaceAddress, key, value);\n      psbt.addOutput({\n        script: nsScript,\n        value: output.value,\n      });\n    } else {\n      psbt.addOutput({\n        address: output.address,\n        value: output.value,\n      });\n    }\n  }\n\n  for (let i = 0; i < keypairs.length; i++) {\n    psbt.signInput(i, keypairs[i]);\n    if (!psbt.validateSignaturesOfInput(i)) {\n      throw new Error('Invalid signature for input #' + i);\n    }\n  }\n\n  psbt.finalizeAllInputs();\n  let hexTx = psbt.extractTransaction(true).toHex();\n  return {tx: hexTx, fee, cost: amount, key};\n}\n\n// Send a reply/comment to a post(key/value pair).\n// replyRootAddress: the root namespace of the post.\n// replyTxid: the txid of the post\n//\nexport async function replyKeyValue(wallet, requestedSatPerByte, namespaceId, shortCode, value, replyRootAddress, replyTxid) {\n  await wallet.fetchBalance();\n  await wallet.fetchTransactions();\n  let nsUtxo = await getNamespaceUtxo(wallet, namespaceId);\n  if (!nsUtxo) {\n    throw new Error(update_key_err);\n  }\n\n  // To reply to a post, the key must be :replyTxid.\n  const key = createReplyKey(replyTxid, shortCode);\n  const namespaceAddress = await wallet.getAddressAsync();\n  const nsScript = getKeyValueUpdateScript(namespaceId, namespaceAddress, key, value);\n\n  // Namespace needs at least 0.01 KVA.\n  const namespaceValue = 1000000;\n  let targets = [{\n    address: namespaceAddress, value: namespaceValue,\n    script: nsScript\n  }, {\n    address: replyRootAddress, value: REPLY_COST,\n  }];\n\n  const transactions = wallet.getTransactions();\n  let utxos = wallet.getUtxo();\n  let nonNamespaceUtxos = await getNonNamespaceUxtos(wallet, transactions, utxos);\n  if (!nonNamespaceUtxos || nonNamespaceUtxos.length == 0) {\n    throw new Error('No nonNamespaceUtxos');\n  }\n  // Move the nsUtxo to the first one, so that it will always be used.\n  nonNamespaceUtxos.unshift(nsUtxo);\n  let { inputs, outputs, fee } = coinSelectAccumulative(nonNamespaceUtxos, targets, requestedSatPerByte);\n  // inputs and outputs will be undefined if no solution was found\n  if (!inputs || !outputs) {\n    throw new Error('Not enough balance. Try sending smaller amount');\n  }\n\n  const psbt = new bitcoin.Psbt();\n  psbt.setVersion(0x7100); // Kevacoin transaction.\n  let keypairs = [];\n  for (let i = 0; i < inputs.length; i++) {\n    let input = inputs[i];\n    const pubkey = wallet._getPubkeyByAddress(input.address);\n    if (!pubkey) {\n      throw new Error('Failed to get pubKey');\n    }\n    const p2wpkh = bitcoin.payments.p2wpkh({ pubkey });\n    const p2sh = bitcoin.payments.p2sh({ redeem: p2wpkh });\n\n    psbt.addInput({\n      hash: input.txId,\n      index: input.vout,\n      witnessUtxo: {\n        script: p2sh.output,\n        value: input.value,\n      },\n      redeemScript: p2wpkh.output,\n    });\n\n    let keyPair = bitcoin.ECPair.fromWIF(input.wif);\n    keypairs.push(keyPair);\n  }\n\n  for (let i = 0; i < outputs.length; i++) {\n    let output = outputs[i];\n    if (!output.address) {\n      // Change address.\n      output.address = await wallet.getChangeAddressAsync();\n    }\n\n    if (i == 0) {\n      // The namespace creation script.\n      if (output.value != 1000000) {\n        throw new Error('Key update script has incorrect value.');\n      }\n      const nsScript = getKeyValueUpdateScript(namespaceId, namespaceAddress, key, value);\n      psbt.addOutput({\n        script: nsScript,\n        value: output.value,\n      });\n    } else {\n      psbt.addOutput({\n        address: output.address,\n        value: output.value,\n      });\n    }\n  }\n\n  for (let i = 0; i < keypairs.length; i++) {\n    psbt.signInput(i, keypairs[i]);\n    if (!psbt.validateSignaturesOfInput(i)) {\n      throw new Error('Invalid signature for input #' + i);\n    }\n  }\n\n  psbt.finalizeAllInputs();\n  let hexTx = psbt.extractTransaction(true).toHex();\n  return {tx: hexTx, fee, cost: REPLY_COST, key};\n}\n\nexport async function deleteKeyValue(wallet, requestedSatPerByte, namespaceId, key) {\n  await wallet.fetchBalance();\n  await wallet.fetchTransactions();\n  let nsUtxo = await getNamespaceUtxo(wallet, namespaceId);\n  if (!nsUtxo) {\n    throw new Error(delete_key_err);\n  }\n\n  const namespaceAddress = await wallet.getAddressAsync();\n  const nsScript = getKeyValueDeleteScript(namespaceId, namespaceAddress, key);\n\n  // Namespace needs at least 0.01 KVA.\n  const namespaceValue = 1000000;\n  let targets = [{\n    address: namespaceAddress, value: namespaceValue,\n    script: nsScript\n  }];\n\n  let utxos = wallet.getUtxo();\n  const transactions = wallet.getTransactions();\n  let nonNamespaceUtxos = await getNonNamespaceUxtos(wallet, transactions, utxos);\n  // Move the nsUtxo to the first one, so that it will always be used.\n  nonNamespaceUtxos.unshift(nsUtxo);\n  let { inputs, outputs, fee } = coinSelectAccumulative(nonNamespaceUtxos, targets, requestedSatPerByte);\n\n  // inputs and outputs will be undefined if no solution was found\n  if (!inputs || !outputs) {\n    throw new Error('Not enough balance. Try sending smaller amount');\n  }\n\n  const psbt = new bitcoin.Psbt();\n  psbt.setVersion(0x7100); // Kevacoin transaction.\n  let keypairs = [];\n  for (let i = 0; i < inputs.length; i++) {\n    let input = inputs[i];\n    const pubkey = wallet._getPubkeyByAddress(input.address);\n    if (!pubkey) {\n      throw new Error('Failed to get pubKey');\n    }\n    const p2wpkh = bitcoin.payments.p2wpkh({ pubkey });\n    const p2sh = bitcoin.payments.p2sh({ redeem: p2wpkh });\n\n    psbt.addInput({\n      hash: input.txId,\n      index: input.vout,\n      witnessUtxo: {\n        script: p2sh.output,\n        value: input.value,\n      },\n      redeemScript: p2wpkh.output,\n    });\n\n    let keyPair = bitcoin.ECPair.fromWIF(input.wif);\n    keypairs.push(keyPair);\n  }\n\n  for (let i = 0; i < outputs.length; i++) {\n    let output = outputs[i];\n    if (!output.address) {\n      // Change address.\n      output.address = await wallet.getChangeAddressAsync();\n    }\n\n    if (i == 0) {\n      // The namespace creation script.\n      if (output.value != 1000000) {\n        throw new Error('Key deletion script has incorrect value.');\n      }\n      const nsScript = getKeyValueDeleteScript(namespaceId, namespaceAddress, key);\n      psbt.addOutput({\n        script: nsScript,\n        value: output.value,\n      });\n    } else {\n      psbt.addOutput({\n        address: output.address,\n        value: output.value,\n      });\n    }\n  }\n\n  for (let i = 0; i < keypairs.length; i++) {\n    psbt.signInput(i, keypairs[i]);\n    if (!psbt.validateSignaturesOfInput(i)) {\n      throw new Error('Invalid signature for input #' + i);\n    }\n  }\n\n  psbt.finalizeAllInputs();\n  let hexTx = psbt.extractTransaction(true).toHex();\n  return {tx: hexTx, fee};\n}\n\n// nsTx: any tx that contains namespace operation.\nexport async function findNamespaceShortCode(ecl, transctions, nsTx) {\n  // Find the \"root\" tx, the first tx that creates the namespace.\n  let result = await getNamespaceDataFromTx(ecl, transctions, nsTx);\n  let txid = result.txid;\n  let rootAddress = result.address;\n  let history = await ecl.blockchainScripthash_getHistory(toScriptHash(result.address));\n  let foundTx = history.find(h => h.tx_hash == txid);\n  if (foundTx) {\n    if (foundTx.height <= 0) {\n      // Still in mempool.\n      return { rootTxid: txid, rootAddress };\n    }\n    let merkle = await ecl.blockchainTransaction_getMerkle(txid, foundTx.height, false);\n    if (merkle) {\n      // The first digit is the length of the block height.\n      let strHeight = merkle.block_height.toString();\n      let prefix = strHeight.length;\n      let shortCode = prefix + strHeight + merkle.pos.toString();\n      return { shortCode, rootTxid: txid, rootAddress };\n    }\n  }\n  return { rootTxid: txid, rootAddress };\n}\n\nexport async function getTxShortCode(ecl, txid, height) {\n  let merkle = await ecl.blockchainTransaction_getMerkle(txid, height, false);\n  if (!merkle) {\n    return -1;\n  }\n\n  // The first digit is the length of the block height.\n  let strHeight = merkle.block_height.toString();\n  let prefix = strHeight.length;\n  let shortCode = prefix + strHeight + merkle.pos.toString();\n  return shortCode;\n}\n\nexport function getHeightFromShortCode(shortCode) {\n  // The first digit is the length of the block height.\n  let len = parseInt(shortCode.charAt(0));\n  let height = parseInt(shortCode.substring(1, len + 1));\n  return height;\n}\n\nexport async function getTxIdFromShortCode(ecl, shortCode) {\n  let prefix = parseInt(shortCode.substring(0, 1));\n  let height = shortCode.substring(1, 1 + prefix);\n  let pos = shortCode.substring(1 + prefix, 2 + prefix);\n  let txHash = await ecl.blockchainTransaction_idFromPos(height, pos);\n  return txHash;\n}\n\nconst VERBOSE = true;\nconst FAST_LOAD = 20;\n\n// Address is the root address, i.e. the address that is involved in\n// namespace creation.\nexport async function fetchKeyValueList(ecl, completeHistory, currentkeyValueList, isFast, cb) {\n\n  let history;\n  if (isFast && completeHistory.length > FAST_LOAD) {\n    // Only load some of the latest results.\n    history = completeHistory.slice(completeHistory.length - FAST_LOAD);\n  } else {\n    history = completeHistory;\n  }\n\n  // Only need to fetch the txs that are not in the current list, or have different height.\n  let txsToFetch = [];\n  currentkeyValueList = currentkeyValueList || [];\n  history.forEach(h => {\n    const same = currentkeyValueList.find(c => (c.tx == h.tx_hash) && (c.height == h.height));\n    if (same) {\n      // No need to update.\n      return;\n    }\n    txsToFetch.push(h.tx_hash);\n  });\n\n  if (txsToFetch.length == 0) {\n    // No changes, return the original ones.\n    return currentkeyValueList;\n  }\n\n  const txsMap = await ecl.multiGetTransactionByTxid(txsToFetch, 20, VERBOSE, cb);\n  let txs = [];\n  for (let t of txsToFetch) {\n    txs.push(txsMap[t]);\n  }\n  let results = [];\n  for (let i = 0; i < txs.length; i++) {\n    let tx = txs[i].result || txs[i];\n    // From transactions, tx.outputs\n    // From server: tx.vout\n    const vout = tx.outputs || tx.vout;\n    for (let v of vout) {\n      let result = parseKeva(v.scriptPubKey.asm);\n      if (!result) {\n        continue;\n      }\n      let resultJson = kevaToJson(result);\n      resultJson.tx = tx.txid;\n      const h = history.find(h => h.tx_hash == tx.txid);\n      resultJson.height = h.height;\n      resultJson.n = v.n;\n      resultJson.time = tx.time;\n      let address = v.scriptPubKey.addresses[0];\n      resultJson.address = address;\n      results.push(resultJson);\n    }\n  }\n\n  // Merge the results. Update the existing ones, and append the rest\n  // to the end;\n  for (let c of currentkeyValueList) {\n    const foundIndex = results.findIndex(r => (r.tx == c.tx));\n    if (foundIndex >= 0) {\n      // Update height in case it is different.\n      c.height = results[foundIndex].height;\n      c.time = results[foundIndex].time;\n      results.splice(foundIndex, 1);\n    }\n  }\n\n  return [...currentkeyValueList, ...results];\n}\n\nexport function mergeKeyValueList(origkeyValues) {\n  // Merge the results.\n  let keyValues = [];\n  for (let kv of origkeyValues) {\n    if (kv.op === 'KEVA_OP_PUT') {\n      // Remove the existing one.\n      keyValues = keyValues.filter(e => e.key != kv.key);\n      keyValues.push(kv);\n    } else if (kv.op === 'KEVA_OP_DELETE') {\n      keyValues = keyValues.filter(e => e.key != kv.key);\n    } else if (kv.op === 'KEVA_OP_NAMESPACE') {\n      keyValues.push({key: '_KEVA_NS_', value: kv.displayName, ...kv});\n    }\n  }\n  return keyValues.reverse();\n}\n\nexport async function findMyNamespaces(wallet, ecl) {\n  await wallet.fetchBalance();\n  await wallet.fetchTransactions();\n  await wallet.fetchUtxo();\n  const transactions = wallet.getTransactions();\n  if (transactions.length == 0) {\n    return;\n  }\n  const UTXOs = wallet.getUtxo();\n  let namespaces = {};\n  for (let tx of transactions) {\n    const isUnspent = UTXOs.find(u => u.txId == tx.hash);\n    if (!isUnspent) {\n      continue;\n    }\n    for (let v of tx.outputs) {\n      let result = parseKeva(v.scriptPubKey.asm);\n      if (!result) {\n          continue;\n      }\n      const keva = kevaToJson(result);\n      const nsId = keva.namespaceId;\n      namespaces[nsId] = namespaces[nsId] || {\n        id: nsId,\n        walletId: wallet.getID(),\n        txId: tx.hash,\n      }\n      if (keva.displayName) {\n        namespaces[nsId].displayName = keva.displayName;\n      }\n    }\n  }\n\n  for (let nsId of Object.keys(namespaces)) {\n    // Find the root txid and short code for each namespace.\n    const { shortCode, rootTxid, rootAddress } = await findNamespaceShortCode(ecl, transactions, namespaces[nsId].txId);\n    namespaces[nsId].shortCode = shortCode;\n    namespaces[nsId].rootTxid = rootTxid;\n    namespaces[nsId].rootAddress = rootAddress;\n    if (!namespaces[nsId].displayName) {\n      // This namespace may be transferred from different wallet.\n      const nsInfo = getNamespaceInfoFromShortCode(ecl, shortCode);\n      if (nsInfo) {\n        namespaces[nsId].displayName = (await nsInfo).displayName;\n      }\n    }\n  }\n  return namespaces;\n}\n\nexport async function findOtherNamespace(ecl, nsidOrShortCode) {\n  let txid;\n  if (nsidOrShortCode.length > 20) {\n    // It is nsid;\n    const nsid = nsidOrShortCode;\n    const history = await ecl.blockchainScripthash_getHistory(getNamespaceScriptHash(nsid));\n    if (!history || history.length == 0) {\n      return null;\n    }\n    txid = history[0].tx_hash;\n  } else {\n    txid = await getTxIdFromShortCode(ecl, nsidOrShortCode);\n  }\n\n  const transactions = [];\n  const { shortCode, rootTxid, rootAddress } = await findNamespaceShortCode(ecl, transactions, txid);\n\n  if (!rootTxid) {\n    return null;\n  }\n\n  let namespaces = {};\n  let nsId;\n  const tx = await ecl.blockchainTransaction_get(rootTxid, true);\n  // From transactions, tx.outputs\n  // From server: tx.vout\n  for (let v of tx.vout) {\n    let result = parseKeva(v.scriptPubKey.asm);\n    if (!result) {\n        continue;\n    }\n    const keva = kevaToJson(result);\n    nsId = keva.namespaceId;\n    namespaces[nsId] = namespaces[nsId] || {\n      id: nsId,\n      txId: tx.txid,\n    }\n    if (keva.displayName) {\n      namespaces[nsId].displayName = keva.displayName;\n    }\n  }\n\n  if (nsId) {\n    namespaces[nsId].shortCode = shortCode;\n    namespaces[nsId].rootTxid = rootTxid;\n    namespaces[nsId].rootAddress = rootAddress;\n  }\n  return namespaces;\n}\n\n// Address is the root address, i.e. the address that is involved in\n// namespace creation.\nexport async function getRepliesAndShares(ecl, rootAddress) {\n  let replies = [];\n  let shares = [];\n  let rewards = []\n  const history = await ecl.blockchainScripthash_getHistory(toScriptHash(rootAddress));\n  const txsToFetch = history.map(h => h.tx_hash);\n  const txsMap = await ecl.multiGetTransactionByTxid(txsToFetch, 20, VERBOSE);\n  let txs = [];\n  for (let t of txsToFetch) {\n    txs.push(txsMap[t]);\n  }\n\n  for (let i = 0; i < txs.length; i++) {\n    let tx = txs[i].result || txs[i];\n    // From transactions, tx.outputs\n    // From server: tx.vout\n    const vout = tx.outputs || tx.vout;\n    for (let v of vout) {\n      let result = parseKeva(v.scriptPubKey.asm);\n      if (!result || result[0] == KEVA_OP_NAMESPACE) {\n        continue;\n      }\n      let resultJson = kevaToJson(result);\n\n      // Check if it is a share\n      const {txIdShortCode, origShortCode, myShortCode} = parseShareKey(resultJson.key);\n      if (txIdShortCode && origShortCode && myShortCode) {\n        // It is a share.\n        resultJson.time = tx.time;\n        const h = history.find(h => h.tx_hash == tx.txid);\n        resultJson.height = h.height;\n        resultJson.sharedTxId = await getTxIdFromShortCode(ecl, txIdShortCode);\n\n        const nsRootId = await getTxIdFromShortCode(ecl, myShortCode);\n        let resultSharer = await getNamespaceDataFromTx(ecl, [], nsRootId);\n        if (!resultSharer) {\n          continue;\n        }\n        const sharer = kevaToJson(resultSharer.result)\n        if (sharer.namespaceId != resultJson.namespaceId) {\n          continue;\n        }\n        resultJson.sharer = {\n          shortCode: myShortCode,\n          rootTxid: nsRootId,\n          displayName: sharer.displayName,\n        }\n        shares.push(resultJson);\n        continue;\n      }\n\n      // Check if it is a reply\n      let partialTxId, shortCode;\n      ({partialTxId, shortCode} = parseReplyKey(resultJson.key));\n      if (partialTxId && shortCode) {\n        resultJson.time = tx.time;\n        const h = history.find(h => h.tx_hash == tx.txid);\n        resultJson.height = h.height;\n\n        const nsRootId = await getTxIdFromShortCode(ecl, shortCode);\n        let resultReplier = await getNamespaceDataFromTx(ecl, [], nsRootId);\n        if (!resultReplier) {\n          continue;\n        }\n        const replier = kevaToJson(resultReplier.result)\n        if (replier.namespaceId != resultJson.namespaceId) {\n          continue;\n        }\n        resultJson.partialTxId = partialTxId;\n        resultJson.sender = {\n          shortCode,\n          rootTxid: nsRootId,\n          displayName: replier.displayName,\n        }\n        replies.push(resultJson);\n        continue;\n      }\n\n      // Check if it is a reward.\n      ({partialTxId, shortCode} = parseRewardKey(resultJson.key));\n      if (!partialTxId || !shortCode) {\n        continue;\n      }\n      resultJson.time = tx.time;\n      const h = history.find(h => h.tx_hash == tx.txid);\n      resultJson.height = h.height;\n\n      const nsRootId = await getTxIdFromShortCode(ecl, shortCode);\n      let resultRewarder = await getNamespaceDataFromTx(ecl, [], nsRootId);\n      if (!resultRewarder) {\n        continue;\n      }\n      const rewarder = kevaToJson(resultRewarder.result)\n      if (rewarder.namespaceId != resultJson.namespaceId) {\n        continue;\n      }\n      resultJson.partialTxId = partialTxId;\n      resultJson.rewarder = {\n        shortCode,\n        rootTxid: nsRootId,\n        displayName: rewarder.displayName,\n      }\n      rewards.push(resultJson);\n    }\n  }\n  return {replies, shares, rewards};\n}\n\nconst SHARE_COST = 1000000;\n\n// Format:\n// \"[shortcode of tx to share]:[shortcode of original namespace]:[shortcode of my namespace]\n// Original namespace is the one that owns the tx.\nfunction createShareKey(txIdShortCode, origShortCode, myShortCode) {\n  return `\"${txIdShortCode}:${origShortCode}:${myShortCode}`\n}\n\n// See createShareKey for format.\nexport function parseShareKey(key) {\n  const regexShare = /^\"([0-9]+):([0-9]+):([0-9]+)$/gm;\n  let matches = regexShare.exec(key);\n  if (!matches) {\n    return false;\n  }\n  return {txIdShortCode: matches[1], origShortCode: matches[2], myShortCode: matches[3]};\n}\n\n// Share a post (key/value pair).\n// replyRootAddress: the root namespace of the post.\n// replyTxid: the txid of the post\n//\nexport async function shareKeyValue(ecl, wallet, requestedSatPerByte, namespaceId, shortCode, origShortCode, value, shareRootAddress, shareTxid, height) {\n  await wallet.fetchBalance();\n  await wallet.fetchTransactions();\n  let nsUtxo = await getNamespaceUtxo(wallet, namespaceId);\n  if (!nsUtxo) {\n    throw new Error(update_key_err);\n  }\n\n  // To share a post, key must be:\n  // \"[shortcode of tx to share]:[shortcode of original namespace]:[shortcode of my namespace]\n  const shareTxidShortCode = await getTxShortCode(ecl, shareTxid, height);\n  const key = createShareKey(shareTxidShortCode, origShortCode, shortCode);\n  const namespaceAddress = await wallet.getAddressAsync();\n  const nsScript = getKeyValueUpdateScript(namespaceId, namespaceAddress, key, value);\n\n  // Namespace needs at least 0.01 KVA.\n  const namespaceValue = 1000000;\n  let targets = [{\n    address: namespaceAddress, value: namespaceValue,\n    script: nsScript\n  }, {\n    address: shareRootAddress, value: SHARE_COST,\n  }];\n\n  const transactions = wallet.getTransactions();\n  let utxos = wallet.getUtxo();\n  let nonNamespaceUtxos = await getNonNamespaceUxtos(wallet, transactions, utxos);\n  // Move the nsUtxo to the first one, so that it will always be used.\n  nonNamespaceUtxos.unshift(nsUtxo);\n  let { inputs, outputs, fee } = coinSelectAccumulative(nonNamespaceUtxos, targets, requestedSatPerByte);\n\n  // inputs and outputs will be undefined if no solution was found\n  if (!inputs || !outputs) {\n    throw new Error('Not enough balance. Try sending smaller amount');\n  }\n\n  const psbt = new bitcoin.Psbt();\n  psbt.setVersion(0x7100); // Kevacoin transaction.\n  let keypairs = [];\n  for (let i = 0; i < inputs.length; i++) {\n    let input = inputs[i];\n    const pubkey = wallet._getPubkeyByAddress(input.address);\n    if (!pubkey) {\n      throw new Error('Failed to get pubKey');\n    }\n    const p2wpkh = bitcoin.payments.p2wpkh({ pubkey });\n    const p2sh = bitcoin.payments.p2sh({ redeem: p2wpkh });\n\n    psbt.addInput({\n      hash: input.txId,\n      index: input.vout,\n      witnessUtxo: {\n        script: p2sh.output,\n        value: input.value,\n      },\n      redeemScript: p2wpkh.output,\n    });\n\n    let keyPair = bitcoin.ECPair.fromWIF(input.wif);\n    keypairs.push(keyPair);\n  }\n\n  for (let i = 0; i < outputs.length; i++) {\n    let output = outputs[i];\n    if (!output.address) {\n      // Change address.\n      output.address = await wallet.getChangeAddressAsync();\n    }\n\n    if (i == 0) {\n      // The namespace creation script.\n      if (output.value != 1000000) {\n        throw new Error('Key update script has incorrect value.');\n      }\n      const nsScript = getKeyValueUpdateScript(namespaceId, namespaceAddress, key, value);\n      psbt.addOutput({\n        script: nsScript,\n        value: output.value,\n      });\n    } else {\n      psbt.addOutput({\n        address: output.address,\n        value: output.value,\n      });\n    }\n  }\n\n  for (let i = 0; i < keypairs.length; i++) {\n    psbt.signInput(i, keypairs[i]);\n    if (!psbt.validateSignaturesOfInput(i)) {\n      throw new Error('Invalid signature for input #' + i);\n    }\n  }\n\n  psbt.finalizeAllInputs();\n  let hexTx = psbt.extractTransaction(true).toHex();\n  return {tx: hexTx, fee, cost: REPLY_COST};\n}\n\nexport async function getKeyValueFromTxid(ecl, txid) {\n  const tx = await ecl.blockchainTransaction_get(txid, true);\n  const vout = tx.vout;\n  for (let v of vout) {\n    let result = parseKeva(v.scriptPubKey.asm);\n    if (result) {\n      let resultJson = kevaToJson(result);\n      resultJson.time = tx.time;\n      return resultJson;\n    }\n  }\n\n  return null;\n}\n\nexport async function getNamespaceInfoFromShortCode(ecl, shortCode) {\n  const nsRootId = await getTxIdFromShortCode(ecl, shortCode);\n  let nsData = await getNamespaceDataFromTx(ecl, [], nsRootId);\n  if (!nsData) {\n    return;\n  }\n  const nsInfo = kevaToJson(nsData.result);\n  return nsInfo;\n}\n","\nexport const makeRequest = (method, params, id) => {\n  return JSON.stringify({\n    jsonrpc: '2.0',\n    method: method,\n    params: params,\n    id: id,\n  });\n};\n\nexport const createPromiseResult = (resolve, reject) => {\n  return (err, result) => {\n    if (err) reject(err);\n    else resolve(result);\n  };\n};\n\nexport const createPromiseResultBatch = (resolve, reject, argz) => {\n  return (err, result) => {\n    if (result && result[0] && result[0].id) {\n      // this is a batch request response\n      for (let r of result) {\n        r.param = argz[r.id];\n      }\n    }\n    if (err) reject(err);\n    else resolve(result);\n  };\n};\n","import { makeRequest, createPromiseResult, createPromiseResultBatch } from './util';\nconst EventEmitter = require('events').EventEmitter;\n\nexport class Client {\n\n  constructor(port, host, protocol, options) {\n    this.id = 0;\n    this.port = port;\n    this.host = host;\n    this.callback_message_queue = {};\n    this.subscribe = new EventEmitter();\n    this._protocol = protocol; // saving defaults\n    this._options = options;\n  }\n\n  connect() {\n    if (this.status === 1) {\n      return Promise.resolve();\n    }\n    this.status = 1;\n    return this.connectSocket(this.port, this.host, this._protocol);\n  }\n\n  connectSocket(port, host, protocol) {\n    return new Promise((resolve, reject) => {\n      let ws = new WebSocket(`${protocol}://${host}:${port}/`);\n      this.ws = ws;\n\n      ws.onopen = () => {\n        console.log(\"connected websocket main component\");\n        resolve();\n      };\n\n      ws.onmessage = (messageEvent) => {\n        this.onMessage(messageEvent.data);\n      }\n\n      ws.onclose = e => {\n        console.log('Socket is closed: ' + JSON.stringify(e));\n        this.status = 0;\n        this.onClose();\n      };\n\n      const errorHandler = e => reject(e);\n      ws.onerror = err => {\n        console.error(\n          \"Socket encountered error: \",\n          err.message,\n          \"Closing socket\"\n        );\n        this.status = 0;\n        ws.close();\n        errorHandler();\n      };\n    });\n  }\n\n  close() {\n    if (this.status === 0) {\n      return;\n    }\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    this.status = 0;\n  }\n\n  request(method, params) {\n    if (this.status === 0) {\n      return Promise.reject(new Error('ESOCKET'));\n    }\n    return new Promise((resolve, reject) => {\n      const id = ++this.id;\n      const content = makeRequest(method, params, id);\n      this.callback_message_queue[id] = createPromiseResult(resolve, reject);\n      this.ws.send(content + '\\n', 'utf8');\n    });\n  }\n\n  requestBatch(method, params, secondParam) {\n    if (this.status === 0) {\n      return Promise.reject(new Error('ESOCKET'));\n    }\n    return new Promise((resolve, reject) => {\n      let arguments_far_calls = {};\n      let contents = [];\n      for (let param of params) {\n        const id = ++this.id;\n        if (secondParam !== undefined) {\n          contents.push(makeRequest(method, [param, secondParam], id));\n        } else {\n          contents.push(makeRequest(method, [param], id));\n        }\n        arguments_far_calls[id] = param;\n      }\n      const content = '[' + contents.join(',') + ']';\n      this.callback_message_queue[this.id] = createPromiseResultBatch(resolve, reject, arguments_far_calls);\n      // callback will exist only for max id\n      this.ws.send(content + '\\n', 'utf8');\n    });\n  }\n\n  response(msg) {\n    let callback;\n    if (!msg.id && msg[0] && msg[0].id) {\n      // this is a response from batch request\n      for (let m of msg) {\n        if (m.id && this.callback_message_queue[m.id]) {\n          callback = this.callback_message_queue[m.id];\n          delete this.callback_message_queue[m.id];\n        }\n      }\n    } else {\n      callback = this.callback_message_queue[msg.id];\n    }\n\n    if (callback) {\n      delete this.callback_message_queue[msg.id];\n      if (msg.error) {\n        callback(msg.error);\n      } else {\n        callback(null, msg.result || msg);\n      }\n    } else {\n      console.log(\"Can't get callback\"); // can't get callback\n    }\n  }\n\n  onMessage(body) {\n    const msg = JSON.parse(body);\n    if (msg instanceof Array) {\n      this.response(msg);\n    } else {\n      if (msg.id !== 0) {\n        this.response(msg);\n      } else {\n        this.subscribe.emit(msg.method, msg.params);\n      }\n    }\n  }\n\n  onClose(e) {\n    this.status = 0;\n    Object.keys(this.callback_message_queue).forEach(key => {\n      this.callback_message_queue[key](new Error('close connect'));\n      delete this.callback_message_queue[key];\n    });\n  }\n\n}\n","import { Client } from './client';\n\nexport class ElectrumClient extends Client {\n\n  constructor(port, host, protocol, options) {\n    super(port, host, protocol, options);\n    this.timeLastCall = 0;\n  }\n\n  initElectrum(electrumConfig, persistencePolicy = { maxRetry: 1000, callback: null }) {\n    this.persistencePolicy = persistencePolicy;\n    this.electrumConfig = electrumConfig;\n    this.timeLastCall = 0;\n    return this.connect().then(() => this.server_version(this.electrumConfig.client, this.electrumConfig.version));\n  }\n\n  // Override parent\n  request(method, params) {\n    this.timeLastCall = new Date().getTime();\n    const parentPromise = super.request(method, params);\n    return parentPromise.then(response => {\n      return response;\n    });\n  }\n\n  requestBatch(method, params, secondParam) {\n    this.timeLastCall = new Date().getTime();\n    const parentPromise = super.requestBatch(method, params, secondParam);\n    return parentPromise.then(response => {\n      return response;\n    });\n  }\n\n  onClose() {\n    super.onClose();\n    const list = [\n      'server.peers.subscribe',\n      'blockchain.numblocks.subscribe',\n      'blockchain.headers.subscribe',\n      'blockchain.address.subscribe',\n    ];\n    list.forEach(event => this.subscribe.removeAllListeners(event));\n    setTimeout(() => {\n      if (this.persistencePolicy != null && this.persistencePolicy.maxRetry > 0) {\n        this.reconnect();\n        this.persistencePolicy.maxRetry -= 1;\n      } else if (this.persistencePolicy != null && this.persistencePolicy.callback != null) {\n        this.persistencePolicy.callback();\n      } else if (this.persistencePolicy == null) {\n        this.reconnect();\n      }\n    }, 10000);\n  }\n\n  // ElectrumX persistancy\n  keepAlive() {\n    if (this.timeout != null) {\n      clearTimeout(this.timeout);\n    }\n    this.timeout = setTimeout(() => {\n      if (this.timeLastCall !== 0 && new Date().getTime() > this.timeLastCall + 5000) {\n        this.server_ping();\n      }\n    }, 5000);\n  }\n\n  close() {\n    super.close();\n    if (this.timeout != null) {\n      clearTimeout(this.timeout);\n    }\n    this.reconnect = this.reconnect = this.onClose = this.keepAlive = () => {}; // dirty hack to make it stop reconnecting\n  }\n\n  reconnect() {\n    this.initSocket();\n    return this.initElectrum(this.electrumConfig);\n  }\n\n  // ElectrumX API\n  server_version(client_name, protocol_version) {\n    return this.request('server.version', [client_name, protocol_version]);\n  }\n  server_banner() {\n    return this.request('server.banner', []);\n  }\n  server_features() {\n    return this.request('server.features', []);\n  }\n  server_ping() {\n    return this.request('server.ping', []);\n  }\n  server_addPeer(features) {\n    return this.request('server.add_peer', [features]);\n  }\n  serverDonation_address() {\n    return this.request('server.donation_address', []);\n  }\n  serverPeers_subscribe() {\n    return this.request('server.peers.subscribe', []);\n  }\n  blockchainAddress_getProof(address) {\n    return this.request('blockchain.address.get_proof', [address]);\n  }\n  blockchainScripthash_getBalance(scripthash) {\n    return this.request('blockchain.scripthash.get_balance', [scripthash]);\n  }\n  blockchainScripthash_getBalanceBatch(scripthash) {\n    return this.requestBatch('blockchain.scripthash.get_balance', scripthash);\n  }\n  blockchainScripthash_listunspentBatch(scripthash) {\n    return this.requestBatch('blockchain.scripthash.listunspent', scripthash);\n  }\n  blockchainScripthash_getHistory(scripthash) {\n    return this.request('blockchain.scripthash.get_history', [scripthash]);\n  }\n  blockchainScripthash_getHistoryBatch(scripthash) {\n    return this.requestBatch('blockchain.scripthash.get_history', scripthash);\n  }\n  blockchainScripthash_getMempool(scripthash) {\n    return this.request('blockchain.scripthash.get_mempool', [scripthash]);\n  }\n  blockchainScripthash_listunspent(scripthash) {\n    return this.request('blockchain.scripthash.listunspent', [scripthash]);\n  }\n  blockchainScripthash_subscribe(scripthash) {\n    return this.request('blockchain.scripthash.subscribe', [scripthash]);\n  }\n  blockchainBlock_getHeader(height) {\n    return this.request('blockchain.block.get_header', [height]);\n  }\n  blockchainBlock_headers(start_height, count) {\n    return this.request('blockchain.block.headeres', [start_height, count]);\n  }\n  blockchainEstimatefee(number) {\n    return this.request('blockchain.estimatefee', [number]);\n  }\n  blockchainHeaders_subscribe(raw) {\n    return this.request('blockchain.headers.subscribe', [raw || false]);\n  }\n  blockchain_relayfee() {\n    return this.request('blockchain.relayfee', []);\n  }\n  blockchainTransaction_broadcast(rawtx) {\n    return this.request('blockchain.transaction.broadcast', [rawtx]);\n  }\n  blockchainTransaction_get(tx_hash, verbose) {\n    return this.request('blockchain.transaction.get', [tx_hash, verbose || false]);\n  }\n  blockchainTransaction_getBatch(tx_hash, verbose) {\n    return this.requestBatch('blockchain.transaction.get', tx_hash, verbose);\n  }\n  blockchainTransaction_getMerkle(tx_hash, height) {\n    return this.request('blockchain.transaction.get_merkle', [tx_hash, height]);\n  }\n  blockchainTransaction_idFromPos(height, txPos, merkle){\n    return this.request('blockchain.transaction.id_from_pos', [height, txPos, merkle || false])\n  }\n  mempool_getFeeHistogram() {\n    return this.request('mempool.get_fee_histogram', []);\n  }\n}\n"],"sourceRoot":""}